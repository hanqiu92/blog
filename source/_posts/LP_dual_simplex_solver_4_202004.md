---
title:       "How to Develop Your Own Dual Simplex Solver IV: Preprocessing Techniques"
categories:  Study Notes
tags:
- Linear Programming
mathjax:     true
date:        2020-04-15 00:00:00
---

在这篇文章中，我将介绍一系列常用的预处理技术，以进一步提升对偶单纯形法的求解效率。

<!--more-->


## 问题形式转换 Transformation

在本系列之前的介绍中，我们假定原始问题具有以下形式
$$
  \begin{aligned}
    \min \ & c^T x \\\\
    s.t. \ & Ax = b, \\\\
           & l \leq x \leq u.
  \end{aligned}
  \label{eq:primal}\tag{1.1}
$$ 相应的对偶问题为
$$
  \begin{aligned}
    \max \ & b^T \lambda + u^T s_u + l^T s_l \\\\
    s.t. \ & A^T \lambda + s_u + s_l = c, \\\\
           & s_l \geq 0, \ s_u \leq 0.
  \end{aligned}
  \label{eq:dual}\tag{1.2}
$$ 但在实际的求解场景中，原始问题一般是按以下形式存储的：
$$
  \begin{aligned}
    \min \\ & c^T x \\\\
    s.t. \\ & b\_l \leq Ax \leq b\_u, \\\\
    & l \leq x \leq u. \\\\
  \end{aligned}
  \label{eq:primal-in}\tag{1.3}
$$ 该形式的好处在于线性约束的表示能力更强，在极端情况下可以节省一半的表示空间。但是，我们无法对这种问题形式应用DS算法；为此，需要将问题\eqref{eq:primal-in}转换成问题\eqref{eq:primal}的形式。一种简单的方法是引入新变量$x^b$来代替$Ax$，从而将线性约束转为上下界约束：
$$
  \begin{aligned}
    \min \ & c^T x + 0^T x^b \\\\
    s.t. \ & Ax - x^b = 0, \\\\
           & l \leq x \leq u, \\ b\_l \leq x^b \leq b\_u.
  \end{aligned}
  \label{eq:primal-in-reform}\tag{1.4}
$$ $x\_b$一般被称为逻辑变量/行变量。上述转换的另一个好处在于转换后的矩阵$\bar{A} = [A;-I]$是满秩的，因此降低了迭代过程中出现高条件数的基矩阵$A\_B$的几率。然而，当线性约束为等式$Ax=b$时，上述转换方式会引入多余的固定值变量$x^b=b$（虽然这并不会影响求解效率）。

在通过DS流程完成对问题\eqref{eq:primal-in-reform}的求解后，需要将结果转换回原问题\eqref{eq:primal-in}的解。通过比较两者的形式易知，原始解$x$的转换是trivial的；而对于对偶解$(\lambda,s)$，注意到问题\eqref{eq:primal-in-reform}对应的对偶问题为
$$
  \begin{aligned}
    \max \ & u^T s\_u + l^T s\_l + b\_u^T s\_u^b + b\_l^T s\_l^b \\\\
    s.t. \ & A^T \lambda + s\_u + s\_l = c, \\\\
           & -\lambda + s\_u^b + s\_l^b = 0, \\\\
           & s\_l,s\_l^b \geq 0, \ s\_u,s\_u^b \leq 0.
  \end{aligned}
  \label{eq:dual-in}\tag{1.5}
$$ 简单分析可知新增的对偶松弛变量$s\_u^b$和$s\_l^b$正好分别对应原问题\eqref{eq:primal-in}中$\leq$和$\geq$方向的约束的对偶变量，因此对偶解的转换也是trivial的。

虽然在DS求解流程中上述问题转换步骤是必需的，但是直接对原问题\eqref{eq:primal-in}进行转换会影响求解效率：原问题形式中一些易于化简的结构可能会在形式转换后变得难以化简。因此，一般在完成其他预处理步骤后再进行问题转换。在下面的讨论中，我都将假定原始问题的形式为问题\eqref{eq:primal-in}。


## 系数缩放 Scaling

在本系列之前的介绍中，我曾提到：DS迭代过程的数值误差很大程度受到矩阵$A\_B$的条件数的影响。由于一个矩阵$A$的条件数与$A^TA$的最大最小特征值的比例有关，而特征值的大小与矩阵系数之间的量级差异有关（一个简单的例子是对角阵$diag([10^5,10^{-5}])$）；因此，可以通过对$A$的系数进行缩放来平衡系数的数量级，而这在一定程度上可降低$A\_B$的条件数以及问题的数值计算难度。

一种简单的系数缩放思路是按行和列进行缩放。具体来说，假设给定行权重$w\_b\in \mathbb{R}^n$和列权重$w\_c \in \mathbb{R}^m$，问题\eqref{eq:primal-in}可等价转化为
$$
  \begin{aligned}
    \min \\ & (w\_c \odot c)^T x^{(w)} \\\\
    s.t. \\ & w\_b \odot b\_l \leq (diag(w\_b) \cdot A \cdot diag(w\_c) )x^{(w)} \leq w\_b \odot b\_u, \\\\
    & (1/w\_c) \odot l \leq x^{(w)} \leq (1/w\_c) \odot u. \\\\
  \end{aligned}
  \label{eq:primal-in-weight}\tag{2.1}
$$ 其中$\odot$表示向量的元素相乘(Hadamard Product)运算，$diag(\cdot)$表示将向量转化成对角矩阵。形式\eqref{eq:primal-in-weight}中同时考虑了行维度和列维度的缩放；通过令$w\_b = \mathbf{1}$或$w\_c = \mathbf{1}$，可以实现只对行维度或列维度进行缩放。

由于我们的目标是平衡矩阵$A$的系数的量级，因此，行/列权重一般被选为行/列系数的量级的倒数。以下是几种常用的权重选取方式：
1. $l\_2$范数：对于行$i$，令$w\_i=1/\sqrt{\sum\_j A\_{ij}^2}$；对于列$j$，令$w\_j=1/\sqrt{\sum\_i A\_{ij}^2}$；
2. $l\_{\infty}$范数（最大值）：对于行$i$，令$w\_i=1/\max\_j |A\_{ij}|$；对于列$j$，令$w\_j=1/\max\_i |A\_{ij}|$；
3. 几何平均(geomean)：对于行$i$，令$w\_i=1/\sqrt{\max\_{\\{j| A\_{ij} \neq 0\\}} |A\_{ij}|\cdot \min\_{\\{j| A\_{ij} \neq 0\\}} |A\_{ij}|}$；
对于列$j$，令$w\_j=1/\sqrt{\max\_{\\{i| A\_{ij} \neq 0\\}} |A\_{ij}|\cdot \min\_{\\{i| A\_{ij} \neq 0\\}} |A\_{ij}|}$。

在实际操作中，一般会多次调用上述缩放方法并配合不同权重选取方式，以获得更优的系数整体平衡效果。例如，在本系列的代码实现中，我将首先使用基于$l\_2$的行+列权重，然后使用基于$l\_{\infty}$的行权重，最后再使用基于$l\_{\infty}$的列权重。


## 问题简化 Reductions

根据此前的理论介绍和数值实验可知，线性代数相关计算是DS迭代过程中的主要计算开销来源（之一）；因此，如果能在进入DS迭代过程之前对线性系统$A$做一些简化，则可以一定程度上降低迭代中的计算量。简化思路主要有以下三点：
1. 减少行（线性约束）的个数。首先，可以根据变量的上下界约束（和其他线性约束）来判断一个线性约束是否是多余的。其次，在DS迭代中，上下界约束相比线性约束更容易处理（计算量更少），因此可以尝试将一些简单的线性约束（等价地）转换为上下界约束。
2. 减少列（决策变量）的个数。首先，可以根据约束和最优性条件，判断变量的取值是否可以固定。其次，可以基于等式约束将变量表示为其他变量的线性组合；不过这种做法可能会导致$A$的非零元素数量增加。
3. 对变量的上下界进行调整。通过放松(relax)上下界约束，可以降低可行域的复杂度（多面体的顶点个数），有利于原始单纯形法(PS)迭代。而通过加强(tighten)上下界约束，特别是将无界转换成有界，可以提高问题的对偶可行程度，有利于DS迭代。另外，在调整上下界约束后，可能可以进一步对行和列进行简化。

需要注意的是，简化后问题和变量的定义发生了变化，因此在求解结束后还需要根据简化问题的结果来恢复原始问题的解；该步骤一般被称为后处理(postprocessing/post-solve)。

接下来，我将介绍几种常用的简化手段（及其后处理方法）。

### 空行/列 Empty Row/Column

空行和空列中没有非零元素，即与其他行和列之间没有相互作用，故在简化步骤中只需要检查相应的（原始/对偶）可行性条件。具体来说，对于一个空行$i$，相应的约束为$b\_{l,i} \leq 0 \leq b\_{u,i}$，因此根据$b\_{l,i}$和$b\_{u,i}$的具体取值，该约束要么是多余的，要么会导致问题原始不可行。对于一个空列$j$，相应的变量$j$只受到上下界约束$l\_j \leq x\_j \leq u\_j$的影响，因此可以根据$c\_j$的符号直接取上界或下界；如果取到的值为$\pm \infty$（即无界），则问题对偶不可行。

在后处理阶段，对于空列$j$，对应的原始变量$x\_j$的取值已知，而对偶松弛变量的取值为
$$s\_j = c\_j - A\_j^T \lambda = c\_j - 0^T \lambda = c\_j; \tag{3.1}
$$对于空行$i$，相应的对偶变量$\lambda\_i$和$s\_{i}^b$都可以直接置0。

### 固定值变量 Fixed-value Column

对于一个变量$j$，其应满足的上下界约束为$l\_j \leq x\_j \leq u\_j$。如果$l\_j > u\_j$，那么问题原始不可行。如果$l\_j = u\_j$，那么可以固定$x\_j$的取值为$l\_j$并去除该变量。进行该简化操作时，$b$的取值需要进行相应改动：
$$b\_l \gets b\_l - A\_j x\_j,b\_u \gets b\_u - A\_j x\_j. \tag{3.2}
$$ 在后处理阶段，原始变量$x\_j$的取值已知，而对偶松弛变量的取值为$s\_j = c\_j - A\_j^T \lambda$。

### 单变量约束 Singleton Row

如果行$i$只包含一个非零元素$A\_{ij}$，那么该线性约束相当于对变量$j$的上下界约束。具体来说，假设该线性约束为$b\_{l,i} \leq A\_{ij}x\_j \leq b\_{u,i}$，其中$A\_{ij} > 0$，那么可以直接将其与已有的上下界$l\_j \leq x\_j \leq u\_j$进行整合：
$$
\max(l\_j,b\_{l,i}/A\_{ij}) \leq x\_j \leq \min(u\_j,b\_{u,i}/A\_{ij}), \tag{3.3}
$$ 并进行相应的可行性判断。

在后处理阶段，需要给出约束$i$对应的对偶变量$\lambda\_i,s\_{l,i}^b,s\_{u,i}^b$的取值。由于$A\_j^T\lambda + s\_j = c\_j$，而$\lambda\_{-i}$的取值已知，因此只需要确定$s\_j$的取值。如果$x\_j$的取值为$l\_j$或$u\_j$，则恢复约束$i$后$x\_j$和$s\_j$的取值不变，有$\lambda\_i = s\_{i}^b = 0$；否则，恢复约束$i$后列$j \in B$，进而有$s\_j = 0, \\ \lambda\_i = (c\_j - A\_{(-i)j}^T\lambda\_{-i})/A\_{ij}$。

### 可行性隐含约束 Feasibly-trivial Row

根据变量的上下界约束$u\_j,l\_j$，可以计算每个线性约束的隐含上下界：
$$
\begin{aligned}
b\_i^+ & = \sum\_{\\{j|A\_{ij} > 0\\}} A\_{ij}u\_j + \sum\_{\\{j|A\_{ij} < 0\\}} A\_{ij}l\_j; \\\\
b\_i^- & = \sum\_{\\{j|A\_{ij} > 0\\}} A\_{ij}l\_j + \sum\_{\\{j|A\_{ij} < 0\\}} A\_{ij}u\_j. \\\\
\end{aligned}\tag{3.4}
$$ 然后可以根据$b\_i^+,b\_i^-,b\_{u,i},b\_{l,i}$的相对大小进行简化。具体来说，如果$b\_i^- > b\_{u,i}$或者$b\_i^+ < b\_{l,i}$，那么该线性约束原始不可行。如果$b\_i^- = b\_{u,i}$或者$b\_i^+ = b\_{l,i}$，那么可以根据式(3.4)固定相关原始变量的取值。如果$b\_{l,i} \leq b\_i^- \leq b\_i^+ \leq b\_{u,i}$，则约束是多余的，可以被去除。

后处理阶段的处理方法需要根据不同的简化情况进行讨论。
* 如果约束$i$是作为多余约束被去除的，那么恢复该约束不影响当前解的可行性，故只需令$i^b\in B$以及对偶变量$\lambda\_i=s\_i^b=0$。
* 如果约束$i$还固定了变量取值，那么该约束是有效的，需要对对偶变量$\lambda\_i$和$s\_j$进行计算。不妨假设$b\_i^- = b\_{u,i}$，则在原问题中约束$i$被固定在上界、值$A\_{ij}x\_j$被固定在下界。因此，对偶变量需要满足以下条件
$$
\begin{aligned}
\lambda\_i & = s\_i^b \leq 0; \\\\
s\_j &
\begin{cases}
    \geq 0, & A\_{ij} > 0; \\\\
    \leq 0, & A\_{ij} < 0. \\\\
\end{cases}
\end{aligned}\tag{3.5}
$$ 又因为新增了一个约束，因此在各恢复的列$j$和$i^b$中间需要有一个进入$B$，其对应的对偶松弛变量必须为0。现在，根据对偶松弛变量的计算公式$s\_j = (c\_j - A\_{(-i)j}^T \lambda\_{-i}) - A\_{ij} \lambda\_i$，可以确定唯一的$\lambda\_i \leq 0$使得(3.5)中所有约束都能满足，且各$s\_j$和$s\_i^b$中恰好有一个为0：$\lambda\_i = \min(\min\_{j}\\{(c\_j - A\_{(-i)j}^T \lambda\_{-i})) / A\_{ij} \\},0)$，并进而确定所有对偶变量的取值。

### 最优性隐含变量 Optimally-trivial Column

上面关于空列的讨论指出，在没有线性约束$b\_l \leq Ax \leq b\_u$的情况下，问题\eqref{eq:primal-in}的最优解是平凡(trivial)的：
$$
x\_j = \begin{cases}
    u\_j, & c\_j < 0; \\\\
    l\_j, & c\_j > 0. \\\\
\end{cases}\tag{3.5}
$$ 如果线性约束$b\_l \leq Ax \leq b\_u$对一个变量$x\_j$取到上述最优解没有明显约束作用，那么可以将该变量当做空列/固定值处理。具体来说，如果$c\_j < 0$且系数$A\_{ij}$满足
$$ A\_{ij} \begin{cases}
    \geq 0, & b\_{u,i} = \infty; \\\\
    \leq 0, & b\_{l,i} = -\infty, \\\\
\end{cases}\tag{3.6}
$$ 那么可以在保持其他变量$x\_{-j}$不变的情况下令$x\_j=u\_j$来最优化目标；因此最优解必然满足$x\_j \equiv u\_j$。同理，我们可以给出$x\_j \equiv l\_j$的简单检查条件。如果在上述简化步骤中列$j$被去除了，那么在后处理阶段可以按以下方式计算和恢复相应的对偶松弛变量：$s\_j = c\_j - A\_j^T \lambda$。

上述简化思路也可以从对偶可行性的角度来理解。根据对偶可行性，如果对偶松弛变量$s\_j$非零，则其符号确定了列$j$的属性$\\{L,U\\}$及$x\_j$的取值。又因为$s\_j = s\_{u,j} + s\_{l,j} = c\_j - A\_j^T \lambda$，因此可以根据对偶变量$\lambda$的上下界$[\lambda^-,\lambda^+]$来检查$s\_j$的符号是否固定。特别地，在没有额外信息的情况下，可以根据等式$\lambda\_i = s\_{u,i}^b + s\_{l,i}^b = s\_i^b$以及$s^b$的平凡上下界$\\{0,\pm\infty\\}$来获取$\lambda$的上下界；这种方式恰好与上述简化思路相对应。也可以进一步通过上下界加强(bound tightening)手段处理$\lambda$的上下界，以期固定更多变量。

### 双变量等式约束 Doubleton Row

如果约束$i$是一个只包含两个变量的等式约束$A\_{ij\_1} x\_{j\_1} + A\_{ij\_2} x\_{j\_2} = b\_i$，那么可以用其中一个变量$x\_{j\_2}$来表示另一个变量$x\_{j\_1}$：$x\_{j\_1} = (b\_i - A\_{ij\_2} x\_{j\_2}) / A\_{ij\_1}$，然后去除变量$x\_{j\_1}$和约束$i$。注意保留变量$x\_{j\_2}$的上下界也需要根据$x\_{j\_1}$的上下界进行调整，可能会变得更紧。

在后处理阶段，原始变量$x\_{j\_1}$可以直接通过上述表示来获取，而对偶变量$\lambda\_i$和$s\_{j\_1},s\_{j\_2}$需要根据列$j\_2$的属性和$x\_{j\_2}$的取值进行相应处理。具体来说，
* 如果$x\_{j\_2}$在原始边界$\\{l\_{j\_2},u\_{j\_2}\\}$上或$j\_2$在$B$中，则恢复变量$x\_{j\_1}$和约束$i$后，$j\_2$的属性和$x\_{j\_2}$的取值不需要进行改变；故可令$j\_1 \in B$，进而$s\_{j\_1} = 0, \ \lambda\_i = (c\_{j\_1} - A\_{(-i)j\_1}^T \lambda\_{-i})/A\_{ij\_1}$。由于恢复前（简化后）的松弛变量$\tilde{s}\_{j\_2}$满足$\tilde{s}\_{j\_2} = s\_{j\_2} - (A\_{ij\_2}/A\_{ij\_1}) s\_{j\_1}$，因此$s\_{j\_2}$的取值没有变化。
* 如果$x\_{j\_2}$在新生成的边界上，那么恢复变量$x\_{j\_1}$和约束$i$后，$j\_2$应进入$B$，故$s\_{j\_2} = 0$，进而可以算得
$$\lambda\_i = (c\_{j\_2} - A\_{(-i)j\_2}^T \lambda\_{-i})/A\_{ij\_2}, \ s\_{j\_2} = - (A\_{ij\_1}/A\_{ij\_2})\tilde{s}\_{j\_2}.$$

接下来，我将在[这个notebook](https://github.com/hanqiu92/dual_simplex_solve/blob/master/4_preprocess.ipynb)中尝试实现上述各预处理方法，并通过数值实验分析效果。
